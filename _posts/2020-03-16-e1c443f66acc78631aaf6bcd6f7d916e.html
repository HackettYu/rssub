---
layout:      post
title:       LeetCode Biweekly Contest 21 (1370 - 1373)
link:        https://programcz.github.io/2020/03/16/LeetCode-Biweekly-Contest-21-(1370-1373).html
date:        2020-03-16 10:24:00
category:    个人博客
source:      ProgramCZ's Blog
description: LeetCode 双周赛专题每双周随缘更新，点击标签 CAT - LeetCode Biweekly Contest 查看更多。  1370. Increasing Decreasing String #Easy 题目解析 首先，使用 map<char, int> um 记录每个字符出现的次数。 其
---

<p>LeetCode 双周赛专题每双周随缘更新，点击标签 <code class="language-plaintext highlighter-rouge">CAT - LeetCode Biweekly Contest</code> 查看更多。</p>

<!--more-->

<h2 id="1370-increasing-decreasing-string-easy"><a href="https://leetcode.com/contest/biweekly-contest-21/problems/increasing-decreasing-string/">1370. Increasing Decreasing String</a> #Easy</h2>

<h3 id="题目解析">题目解析</h3>

<p>首先，使用 <code class="language-plaintext highlighter-rouge">map&lt;char, int&gt; um</code> 记录每个字符出现的次数。</p>

<p>其次，因为 <code class="language-plaintext highlighter-rouge">map</code> 在插入过程中自动排序，所以从头到尾遍历可以得到字符的升序序列，同样从尾到头遍历可以得到字符的降序序列，不断循环上述步骤，直到用完所有字符即可。</p>

<h4 id="c-实现">C++ 实现</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">sortString</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">um</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="p">)</span> <span class="o">++</span><span class="n">um</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">string</span> <span class="n">res</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">um</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">um</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
                    <span class="o">--</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
                    <span class="o">++</span><span class="n">cnt</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">um</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">um</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">res</span> <span class="o">+=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
                    <span class="o">--</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
                    <span class="o">++</span><span class="n">cnt</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="1371-find-the-longest-substring-containing-vowels-in-even-counts-medium"><a href="https://leetcode.com/contest/biweekly-contest-21/problems/find-the-longest-substring-containing-vowels-in-even-counts/">1371. Find the Longest Substring Containing Vowels in Even Counts</a> #Medium</h2>

<h3 id="题目解析-1">题目解析</h3>

<blockquote>
  <p>参考：<a href="https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/534135/C%2B%2BJava-with-picture">C++/Java with picture - LeetCode</a></p>
</blockquote>

<p>首先，使用掩码 <code class="language-plaintext highlighter-rouge">mask</code>，其中的五位分别对应五个字符，位为 <code class="language-plaintext highlighter-rouge">0</code> 代表该字符出现次数为偶数，位为 <code class="language-plaintext highlighter-rouge">1</code> 代表该字符出现次数为奇数。那么，掩码 <code class="language-plaintext highlighter-rouge">mask</code> 可能出现的情况共有 <code class="language-plaintext highlighter-rouge">32</code> 种，使用 <code class="language-plaintext highlighter-rouge">iarr</code> 记录每种情况第一次出现的位置。</p>

<p>其次，遍历字符串 <code class="language-plaintext highlighter-rouge">s</code>，将掩码 <code class="language-plaintext highlighter-rouge">mask</code> 与每个字符对应的编码进行异或运算，计算当前的位置与该掩码第一次出现的位置之间子串的长度，比较最大值即可。</p>

<p class="info">需要明白的是，如果 <code class="language-plaintext highlighter-rouge">i</code> 和 <code class="language-plaintext highlighter-rouge">j</code> 两个位置具有相同的掩码 <code class="language-plaintext highlighter-rouge">mask</code>，那么 <code class="language-plaintext highlighter-rouge">[i + 1, j]</code> 之间的子串必然是满足题意的。</p>

<h4 id="c-实现-1">C++ 实现</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">findTheLongestSubstring</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">array</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">26</span><span class="o">&gt;</span> <span class="n">carr</span><span class="p">;</span>
        <span class="n">fill</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">carr</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">carr</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">carr</span><span class="p">[</span><span class="sc">'a'</span><span class="o">-</span><span class="sc">'a'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">carr</span><span class="p">[</span><span class="sc">'e'</span><span class="o">-</span><span class="sc">'a'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">carr</span><span class="p">[</span><span class="sc">'i'</span><span class="o">-</span><span class="sc">'a'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">carr</span><span class="p">[</span><span class="sc">'o'</span><span class="o">-</span><span class="sc">'a'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
        <span class="n">carr</span><span class="p">[</span><span class="sc">'u'</span><span class="o">-</span><span class="sc">'a'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
        <span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">iarr</span><span class="p">;</span>
        <span class="n">fill</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">iarr</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">iarr</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mask</span> <span class="o">^=</span> <span class="n">carr</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">'a'</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iarr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">iarr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">iarr</span><span class="p">[</span><span class="n">mask</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="1372-longest-zigzag-path-in-a-binary-tree-medium"><a href="https://leetcode.com/contest/biweekly-contest-21/problems/longest-zigzag-path-in-a-binary-tree/">1372. Longest ZigZag Path in a Binary Tree</a> #Medium</h2>

<h3 id="题目解析-2">题目解析</h3>

<p>递归遍历树，使用 <code class="language-plaintext highlighter-rouge">is_left</code> 标记是否为左节点。</p>

<p class="info">需要注意的是，如果当前节点为其父节点的左节点，那么可以在之前深度 <code class="language-plaintext highlighter-rouge">depth</code> 的基础上遍历其右节点，也可以从 <code class="language-plaintext highlighter-rouge">0</code> 开始遍历其左节点。右节点亦然。</p>

<h4 id="c-实现-2">C++ 实现</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">longestZigZag</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">helper1</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="n">helper1</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">helper1</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_left</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">helper1</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
            <span class="n">helper1</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">helper1</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
            <span class="n">helper1</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="1373-maximum-sum-bst-in-binary-tree-hard"><a href="https://leetcode.com/contest/biweekly-contest-21/problems/maximum-sum-bst-in-binary-tree/">1373. Maximum Sum BST in Binary Tree</a> #Hard</h2>

<h3 id="题目解析-3">题目解析</h3>

<blockquote>
  <p>参考：<a href="https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/534900/C%2B%2B-Naive-%2B-Correct">C++ Naive + Correct - LeetCode</a></p>
</blockquote>

<p>递归遍历树，使用 <code class="language-plaintext highlighter-rouge">array&lt;int, 3&gt;</code> 记录子树的和、最小值和最大值。</p>

<p>如果左子树的最大值小于当前节点的值，而且右子树的最小值大于当前节点的值，那么说明以当前节点为根节点的树为 BST，传递该树的和、最小值和最大值，否则传递 <code class="language-plaintext highlighter-rouge">{0, INT_MIN, INT_MAX}</code>。</p>

<h4 id="c-实现-3">C++ 实现</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">maxSumBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">helper1</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">helper1</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">l</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">?</span> <span class="n">helper1</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
                            <span class="o">:</span> <span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">INT_MIN</span><span class="p">};</span>
        <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">?</span> <span class="n">helper1</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
                             <span class="o">:</span> <span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">};</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">+</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">+</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]};</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="n">INT_MIN</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">};</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>